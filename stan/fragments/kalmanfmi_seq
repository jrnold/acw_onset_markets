// observation level log-lik
vector[N] llik;
// filtered values
vector[n] m; 
matrix[n, n] C;
// forecasts
real f;
real Q;

vector[r] f_save[N];
vector[r] Q_save[N];
vector[n] m_save[N];
matrix[n, n] C_save[N];

// temporary values
vector[r] LL;
real err;
vector[n] A;
real Q_inv;
vector[n] Fj;
matrix[n, n] jos;

m <- m0;
C <- C0;
for (i in 1:N) {
  // predictive distribution
  // reusing m and C
  m <- G * m + d;
  // C <- G * C * G ' + W;
  C <- quad_form(C, G ') + W;
  for (j in 1:r) {
    Fj <- col(F, j);
    f <- dot_product(Fj, m) + b[j];
    Q <- Fj ' * C * Fj + V[j];
    Q <- 0.5 * (Q + Q ');
    if (int_step(mask[i, j])) {
      LL[j] <- 0.0;
    } else {
      e <- y[i, j] - f;
      Q_inv <- 1.0 / Q;
      A <- C * Fj * Q_inv;
      m <- m + A * err;
      // C <- C - Q * tcrossprod(A);
      // C <- 0.5 * (C + C');
      jos <- (I - A * F');
      C <- jos * C * jos ' + A * V * A ';
      C <- quad_form(C, jos ') + quad_form(V, A ');
      // Saving
      LL[j] <- (-0.5 * (log(Q) + Q_inv * pow(e, 2)));
    }
    f_save[i, j] <- f;
    Q_save[i, j] <- Q;
  }
  m_save[i] <- m;
  C_save[i] <- C;
  
  // filtered states
  llik[i] <- sum(LL);
 }

